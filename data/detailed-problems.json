{
    "categories": [
      {
        "id": "array",
        "name": "Array",
        "problems": [
          {
            "id": 1,
            "title": "Remove Duplicates from Sorted Array",
            "difficulty": "Easy",
            "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.",
            "examples": [
              {
                "input": "nums = [1,1,2]",
                "output": "2",
                "explanation": "Your function should return k = 2, with the first two elements being 1 and 2."
              },
              {
                "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
                "output": "5",
                "explanation": "Your function should return k = 5, with the first five elements being 0, 1, 2, 3, and 4."
              }
            ],
            "constraints": [
              "0 <= nums.length <= 3 * 10^4",
              "-10^4 <= nums[i] <= 10^4",
              "nums is sorted in non-decreasing order."
            ],
            "testCases": [
              { "input": { "nums": [1,1,2] }, "output": 2 },
              { "input": { "nums": [0,0,1,1,1,2,2,3,3,4] }, "output": 5 }
            ],
            "javaTemplate": "class Solution { public int removeDuplicates(int[] nums) { return 0; } }",
            "pythonTemplate": "class Solution: def removeDuplicates(self, nums: List[int]) -> int: pass",
            "cppTemplate": "class Solution { public: int removeDuplicates(vector<int>& nums) { return 0; } };"
          },
          {
            "id": 2,
            "title": "Two Sum",
            "difficulty": "Easy",
            "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
            "examples": [
              {
                "input": "nums = [2,7,11,15], target = 9",
                "output": "[0,1]",
                "explanation": "Because `nums[0] + nums[1] == 9`, we return `[0, 1]`."
              },
              {
                "input": "nums = [3,2,4], target = 6",
                "output": "[1,2]"
              }
            ],
            "constraints": [
              "2 <= nums.length <= 10^4",
              "-10^9 <= nums[i] <= 10^9",
              "-10^9 <= target <= 10^9",
              "Only one valid answer exists."
            ],
            "testCases": [
              { "input": { "nums": [2,7,11,15], "target": 9 }, "output": [0,1] },
              { "input": { "nums": [3,2,4], "target": 6 }, "output": [1,2] }
            ],
            "javaTemplate": "class Solution { public int[] twoSum(int[] nums, int target) { return null; } }",
            "pythonTemplate": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: pass",
            "cppTemplate": "class Solution { public: vector<int> twoSum(vector<int>& nums, int target) { return {}; } };"
          },
          {
            "id": 3,
            "title": "Best Time to Buy and Sell Stock",
            "difficulty": "Easy",
            "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`^th day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
            "examples": [
              {
                "input": "prices = [7,1,5,3,6,4]",
                "output": "5",
                "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must sell after you buy."
              },
              {
                "input": "prices = [7,6,4,3,1]",
                "output": "0",
                "explanation": "In this case, no transactions are done and the max profit is 0."
              }
            ],
            "constraints": [
              "1 <= prices.length <= 10^5",
              "0 <= prices[i] <= 10^4"
            ],
            "testCases": [
              { "input": { "prices": [7,1,5,3,6,4] }, "output": 5 },
              { "input": { "prices": [7,6,4,3,1] }, "output": 0 }
            ],
            "javaTemplate": "class Solution { public int maxProfit(int[] prices) { return 0; } }",
            "pythonTemplate": "class Solution: def maxProfit(self, prices: List[int]) -> int: pass",
            "cppTemplate": "class Solution { public: int maxProfit(vector<int>& prices) { return 0; } };"
          },
          {
            "id": 4,
            "title": "Contains Duplicate",
            "difficulty": "Easy",
            "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
            "examples": [
              {
                "input": "nums = [1,2,3,1]",
                "output": "true"
              },
              {
                "input": "nums = [1,2,3,4]",
                "output": "false"
              }
            ],
            "constraints": [
              "1 <= nums.length <= 10^5",
              "-10^9 <= nums[i] <= 10^9"
            ],
            "testCases": [
              { "input": { "nums": [1,2,3,1] }, "output": true },
              { "input": { "nums": [1,2,3,4] }, "output": false }
            ],
            "javaTemplate": "class Solution { public boolean containsDuplicate(int[] nums) { return false; } }",
            "pythonTemplate": "class Solution: def containsDuplicate(self, nums: List[int]) -> bool: pass",
            "cppTemplate": "class Solution { public: bool containsDuplicate(vector<int>& nums) { return false; } };"
          },
          {
            "id": 5,
            "title": "Move Zeroes",
            "difficulty": "Easy",
            "description": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.",
            "examples": [
              {
                "input": "nums = [0,1,0,3,12]",
                "output": "[1,3,12,0,0]"
              },
              {
                "input": "nums = [0]",
                "output": "[0]"
              }
            ],
            "constraints": [
              "1 <= nums.length <= 10^4",
              "-2^31 <= nums[i] <= 2^31 - 1"
            ],
            "testCases": [
              { "input": { "nums": [0,1,0,3,12] }, "output": [1,3,12,0,0] },
              { "input": { "nums": [0] }, "output": [0] }
            ],
            "javaTemplate": "class Solution { public void moveZeroes(int[] nums) {} }",
            "pythonTemplate": "class Solution: def moveZeroes(self, nums: List[int]) -> None: pass",
            "cppTemplate": "class Solution { public: void moveZeroes(vector<int>& nums) {} };"
          }
        ]
      },
      {
        "id": "hashtable",
        "name": "Hash Table",
        "problems": [
          {
            "id": 5,
            "title": "Intersection of Two Arrays II",
            "difficulty": "Easy",
            "description": "Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.",
            "examples": [
              {
                "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
                "output": "[2,2]"
              },
              {
                "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
                "output": "[4,9]"
              }
            ],
            "constraints": [
              "1 <= nums1.length, nums2.length <= 1000",
              "0 <= nums1[i], nums2[i] <= 1000"
            ],
            "testCases": [
              { "input": { "nums1": [1,2,2,1], "nums2": [2,2] }, "output": [2,2] },
              { "input": { "nums1": [4,9,5], "nums2": [9,4,9,8,4] }, "output": [4,9] }
            ],
            "javaTemplate": "class Solution { public int[] intersect(int[] nums1, int[] nums2) { return null; } }",
            "pythonTemplate": "class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]: pass",
            "cppTemplate": "class Solution { public: vector<int> intersect(vector<int>& nums1, vector<int>& nums2) { return {}; } };"
          },
          {
            "id": 6,
            "title": "Maximum Subarray",
            "difficulty": "Easy",
            "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.",
            "examples": [
              {
                "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                "output": "6",
                "explanation": "The subarray `[4,-1,2,1]` has the largest sum 6."
              },
              {
                "input": "nums = [1]",
                "output": "1"
              }
            ],
            "constraints": [
              "1 <= nums.length <= 10^5",
              "-10^4 <= nums[i] <= 10^4"
            ],
            "testCases": [
              { "input": { "nums": [-2,1,-3,4,-1,2,1,-5,4] }, "output": 6 },
              { "input": { "nums": [1] }, "output": 1 }
            ],
            "javaTemplate": "class Solution { public int maxSubArray(int[] nums) { return 0; } }",
            "pythonTemplate": "class Solution: def maxSubArray(self, nums: List[int]) -> int: pass",
            "cppTemplate": "class Solution { public: int maxSubArray(vector<int>& nums) { return 0; } };"
          },
          {
            "id": 7,
            "title": "Product of Array Except Self",
            "difficulty": "Medium",
            "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in `O(n)` time and without using the division operator.",
            "examples": [
              {
                "input": "nums = [1,2,3,4]",
                "output": "[24,12,8,6]"
              },
              {
                "input": "nums = [-1,1,0,-3,3]",
                "output": "[0,0,9,0,0]"
              }
            ],
            "constraints": [
              "2 <= nums.length <= 10^5",
              "-30 <= nums[i] <= 30"
            ],
            "testCases": [
              { "input": { "nums": [1,2,3,4] }, "output": [24,12,8,6] },
              { "input": { "nums": [-1,1,0,-3,3] }, "output": [0,0,9,0,0] }
            ],
            "javaTemplate": "class Solution { public int[] productExceptSelf(int[] nums) { return null; } }",
            "pythonTemplate": "class Solution: def productExceptSelf(self, nums: List[int]) -> List[int]: pass",
            "cppTemplate": "class Solution { public: vector<int> productExceptSelf(vector<int>& nums) { return {}; } };"
          },
          {
            "id": 8,
            "title": "3Sum",
            "difficulty": "Medium",
            "description": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. Notice that the solution set must not contain duplicate triplets.",
            "examples": [
              {
                "input": "nums = [-1,0,1,2,-1,-4]",
                "output": "[[-1,-1,2],[-1,0,1]]"
              },
              {
                "input": "nums = [0,1,1]",
                "output": "[]"
              }
            ],
            "constraints": [
              "3 <= nums.length <= 3000",
              "-10^5 <= nums[i] <= 10^5"
            ],
            "testCases": [
              { "input": { "nums": [-1,0,1,2,-1,-4] }, "output": [[-1,-1,2],[-1,0,1]] },
              { "input": { "nums": [0,1,1] }, "output": [] }
            ],
            "javaTemplate": "class Solution { public List<List<Integer>> threeSum(int[] nums) { return null; } }",
            "pythonTemplate": "class Solution: def threeSum(self, nums: List[int]) -> List[List[int]]: pass",
            "cppTemplate": "class Solution { public: vector<vector<int>> threeSum(vector<int>& nums) { return {}; } };"
          },
          {
            "id": 9,
            "title": "Group Anagrams",
            "difficulty": "Medium",
            "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
              {
                "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
                "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
              },
              {
                "input": "strs = [\"\"]",
                "output": "[[\"\"]]"
              }
            ],
            "constraints": [
              "1 <= strs.length <= 10^4",
              "0 <= strs[i].length <= 100",
              "strs[i] consists of lowercase English letters."
            ],
            "testCases": [
              { "input": { "strs": ["eat","tea","tan","ate","nat","bat"] }, "output": [["bat"],["nat","tan"],["ate","eat","tea"]] },
              { "input": { "strs": [""] }, "output": [[""]] }
            ],
            "javaTemplate": "class Solution { public List<List<String>> groupAnagrams(String[] strs) { return null; } }",
            "pythonTemplate": "class Solution: def groupAnagrams(self, strs: List[str]) -> List[List[str]]: pass",
            "cppTemplate": "class Solution { public: vector<vector<string>> groupAnagrams(vector<string>& strs) { return {}; } };"
          },
          {
            "id": 10,
            "title": "Valid Parentheses",
            "difficulty": "Easy",
            "description": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type.",
            "examples": [
              {
                "input": "s = \"()\"",
                "output": "true"
              },
              {
                "input": "s = \"()[]{}\"",
                "output": "true"
              }
            ],
            "constraints": [
              "1 <= s.length <= 10^4",
              "s consists of parentheses only `'()[]{}'`."
            ],
            "testCases": [
              { "input": { "s": "()" }, "output": true },
              { "input": { "s": "()[]{}" }, "output": true }
            ],
            "javaTemplate": "class Solution { public boolean isValid(String s) { return false; } }",
            "pythonTemplate": "class Solution: def isValid(self, s: str) -> bool: pass",
            "cppTemplate": "class Solution { public: bool isValid(string s) { return false; } };"
          },
          {
            "id": 11,
            "title": "Valid Palindrome",
            "difficulty": "Easy",
            "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
            "examples": [
              {
                "input": "s = \"A man, a plan, a canal: Panama\"",
                "output": "true",
                "explanation": "The phrase becomes \"amanaplanacanalpanama\". It is a palindrome."
              },
              {
                "input": "s = \"race a car\"",
                "output": "false",
                "explanation": "The phrase becomes \"raceacar\". It is not a palindrome."
              }
            ],
            "constraints": [
              "1 <= s.length <= 2 * 10^5",
              "s consists only of printable ASCII characters."
            ],
            "testCases": [
              { "input": { "s": "A man, a plan, a canal: Panama" }, "output": true },
              { "input": { "s": "race a car" }, "output": false }
            ],
            "javaTemplate": "class Solution { public boolean isPalindrome(String s) { return false; } }",
            "pythonTemplate": "class Solution: def isPalindrome(self, s: str) -> bool: pass",
            "cppTemplate": "class Solution { public: bool isPalindrome(string s) { return false; } };"
          },
          {
            "id": 12,
            "title": "Is Anagram",
            "difficulty": "Easy",
            "description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
              {
                "input": "s = \"anagram\", t = \"nagaram\"",
                "output": "true"
              },
              {
                "input": "s = \"rat\", t = \"car\"",
                "output": "false"
              }
            ],
            "constraints": [
              "1 <= s.length, t.length <= 5 * 10^4",
              "s and t consist of lowercase English letters."
            ],
            "testCases": [
              { "input": { "s": "anagram", "t": "nagaram" }, "output": true },
              { "input": { "s": "rat", "t": "car" }, "output": false }
            ],
            "javaTemplate": "class Solution { public boolean isAnagram(String s, String t) { return false; } }",
            "pythonTemplate": "class Solution: def isAnagram(self, s: str, t: str) -> bool: pass",
            "cppTemplate": "class Solution { public: bool isAnagram(string s, string t) { return false; } };"
          }
        ]
      },
      {
        "id": "linkedlist",
        "name": "Linked List",
        "problems": [
          {
            "id": 13,
            "title": "Reverse Linked List",
            "difficulty": "Easy",
            "description": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.",
            "examples": [
              {
                "input": "head = [1,2,3,4,5]",
                "output": "[5,4,3,2,1]"
              },
              {
                "input": "head = [1,2]",
                "output": "[2,1]"
              }
            ],
            "constraints": [
              "The number of nodes in the list is the range [0, 5000].",
              "-5000 <= Node.val <= 5000"
            ],
            "testCases": [
              { "input": { "head": [1,2,3,4,5] }, "output": [5,4,3,2,1] },
              { "input": { "head": [1,2] }, "output": [2,1] }
            ],
            "javaTemplate": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */\nclass Solution { public ListNode reverseList(ListNode head) { return null; } }",
            "pythonTemplate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution: def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]: pass",
            "cppTemplate": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */\nclass Solution { public: ListNode* reverseList(ListNode* head) { return nullptr; } };"
          },
          {
            "id": 14,
            "title": "Merge Two Sorted Lists",
            "difficulty": "Easy",
            "description": "You are given the heads of two sorted linked lists `list1` and `list2`. Merge the two lists into one **sorted** list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
            "examples": [
              {
                "input": "list1 = [1,2,4], list2 = [1,3,4]",
                "output": "[1,1,2,3,4,4]"
              },
              {
                "input": "list1 = [], list2 = []",
                "output": "[]"
              }
            ],
            "constraints": [
              "The number of nodes in both lists is in the range [0, 50].",
              "-100 <= Node.val <= 100",
              "Both `list1` and `list2` are sorted in non-decreasing order."
            ],
            "testCases": [
              { "input": { "list1": [1,2,4], "list2": [1,3,4] }, "output": [1,1,2,3,4,4] },
              { "input": { "list1": [], "list2": [] }, "output": [] }
            ],
            "javaTemplate": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */\\nclass Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { return null; } }",
            "pythonTemplate": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]: pass",
            "cppTemplate": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */\\nclass Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { return nullptr; } };"
          },
          {
            "id": 15,
            "title": "Remove Duplicates from Sorted List",
            "difficulty": "Easy",
            "description": "Given the `head` of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.",
            "examples": [
              {
                "input": "head = [1,1,2]",
                "output": "[1,2]"
              },
              {
                "input": "head = [1,1,2,3,3]",
                "output": "[1,2,3]"
              }
            ],
            "constraints": [
              "The number of nodes in the list is in the range [0, 300].",
              "-100 <= Node.val <= 100",
              "The list is guaranteed to be sorted in ascending order."
            ],
            "testCases": [
              { "input": { "head": [1,1,2] }, "output": [1,2] },
              { "input": { "head": [1,1,2,3,3] }, "output": [1,2,3] }
            ],
            "javaTemplate": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */\\nclass Solution { public ListNode deleteDuplicates(ListNode head) { return null; } }",
            "pythonTemplate": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution: def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]: pass",
            "cppTemplate": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */\\nclass Solution { public: ListNode* deleteDuplicates(ListNode* head) { return nullptr; } };"
          }
        ]
      },
      {
        "id": "slidingwindow",
        "name": "Sliding Window",
        "problems": [
          {
            "id": 16,
            "title": "Longest Substring Without Repeating Characters",
            "difficulty": "Medium",
            "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
            "examples": [
              {
                "input": "s = \"abcabcbb\"",
                "output": "3",
                "explanation": "The answer is \"abc\", with the length of 3."
              },
              {
                "input": "s = \"bbbbb\"",
                "output": "1",
                "explanation": "The answer is \"b\", with the length of 1."
              }
            ],
            "constraints": [
              "0 <= s.length <= 5 * 10^4",
              "s consists of English letters, digits, symbols and spaces."
            ],
            "testCases": [
              { "input": { "s": "abcabcbb" }, "output": 3 },
              { "input": { "s": "bbbbb" }, "output": 1 }
            ],
            "javaTemplate": "class Solution { public int lengthOfLongestSubstring(String s) { return 0; } }",
            "pythonTemplate": "class Solution: def lengthOfLongestSubstring(self, s: str) -> int: pass",
            "cppTemplate": "class Solution { public: int lengthOfLongestSubstring(string s) { return 0; } };"
          }
        ]
      },
      {
        "id": "twopointers",
        "name": "Two Pointers",
        "problems": [
          {
            "id": 17,
            "title": "Container With Most Water",
            "difficulty": "Medium",
            "description": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i`^th line are `(i, 0)` and `(i, height[i])`. Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container.",
            "examples": [
              {
                "input": "height = [1,8,6,2,5,4,8,3,7]",
                "output": "49",
                "explanation": "The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49."
              },
              {
                "input": "height = [1,1]",
                "output": "1"
              }
            ],
            "constraints": [
              "n == height.length",
              "2 <= n <= 10^5",
              "0 <= height[i] <= 10^4"
            ],
            "testCases": [
              { "input": { "height": [1,8,6,2,5,4,8,3,7] }, "output": 49 },
              { "input": { "height": [1,1] }, "output": 1 }
            ],
            "javaTemplate": "class Solution { public int maxArea(int[] height) { return 0; } }",
            "pythonTemplate": "class Solution: def maxArea(self, height: List[int]) -> int: pass",
            "cppTemplate": "class Solution { public: int maxArea(vector<int>& height) { return 0; } };"
          }
        ]
      },
      {
        "id": "math",
        "name": "Math",
        "problems": [
          {
            "id": 18,
            "title": "Plus One",
            "difficulty": "Easy",
            "description": "You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the `i`^th digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s. Increment the large integer by one and return the resulting array of digits.",
            "examples": [
              {
                "input": "digits = [1,2,3]",
                "output": "[1,2,4]",
                "explanation": "The array represents the integer 123."
              },
              {
                "input": "digits = [9]",
                "output": "[1,0]",
                "explanation": "The array represents the integer 9."
              }
            ],
            "constraints": [
              "1 <= digits.length <= 100",
              "0 <= digits[i] <= 9",
              "`digits` does not contain any leading zeros, except for the number 0 itself."
            ],
            "testCases": [
              { "input": { "digits": [1,2,3] }, "output": [1,2,4] },
              { "input": { "digits": [9] }, "output": [1,0] }
            ],
            "javaTemplate": "class Solution { public int[] plusOne(int[] digits) { return null; } }",
            "pythonTemplate": "class Solution: def plusOne(self, digits: List[int]) -> List[int]: pass",
            "cppTemplate": "class Solution { public: vector<int> plusOne(vector<int>& digits) { return {}; } };"
          }
        ]
      },
      {
        "id": "sorting",
        "name": "Sorting",
        "problems": [
          {
            "id": 19,
            "title": "Merge Intervals",
            "difficulty": "Medium",
            "description": "Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
            "examples": [
              {
                "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
                "output": "[[1,6],[8,10],[15,18]]",
                "explanation": "Since [1,3] and [2,6] overlap, merge them into [1,6]."
              },
              {
                "input": "intervals = [[1,4],[4,5]]",
                "output": "[[1,5]]",
                "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
              }
            ],
            "constraints": [
              "1 <= intervals.length <= 10^4",
              "intervals[i].length == 2",
              "0 <= start_i <= end_i <= 10^4"
            ],
            "testCases": [
              { "input": { "intervals": [[1,3],[2,6],[8,10],[15,18]] }, "output": [[1,6],[8,10],[15,18]] },
              { "input": { "intervals": [[1,4],[4,5]] }, "output": [[1,5]] }
            ],
            "javaTemplate": "class Solution { public int[][] merge(int[][] intervals) { return null; } }",
            "pythonTemplate": "class Solution: def merge(self, intervals: List[List[int]]) -> List[List[int]]: pass",
            "cppTemplate": "class Solution { public: vector<vector<int>> merge(vector<vector<int>>& intervals) { return {}; } };"
          }
        ]
      },
      {
        "id": "binarysearch",
        "name": "Binary Search",
        "problems": [
          {
            "id": 20,
            "title": "Search in Rotated Sorted Array",
            "difficulty": "Medium",
            "description": "There is an integer array `nums` sorted in ascending order (with distinct values). Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`. Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`. You must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
              {
                "input": "nums = [4,5,6,7,0,1,2], target = 0",
                "output": "4"
              },
              {
                "input": "nums = [4,5,6,7,0,1,2], target = 3",
                "output": "-1"
              }
            ],
            "constraints": [
              "1 <= nums.length <= 5000",
              "-10^4 <= nums[i] <= 10^4",
              "All values of `nums` are unique.",
              "`nums` is guaranteed to be rotated at some pivot."
            ],
            "testCases": [
              { "input": { "nums": [4,5,6,7,0,1,2], "target": 0 }, "output": 4 },
              { "input": { "nums": [4,5,6,7,0,1,2], "target": 3 }, "output": -1 }
            ],
            "javaTemplate": "class Solution { public int search(int[] nums, int target) { return 0; } }",
            "pythonTemplate": "class Solution: def search(self, nums: List[int], target: int) -> int: pass",
            "cppTemplate": "class Solution { public: int search(vector<int>& nums, int target) { return 0; } };"
          }
        ]
      }
    ]
  }