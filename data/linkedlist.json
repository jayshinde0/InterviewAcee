{
  "category": "Linked List",
  "problems": [
    {
      "id": 41,
      "title": "Reverse Linked List",
      "difficulty": "Easy",
      "description": "Given the `head` of a singly linked list, reverse the list, and return the reversed list. You can reverse the list either iteratively or recursively.",
      "hint": "You can use three pointers to traverse the list and reverse the pointers: `prev`, `curr`, and `next_temp`.",
      "examples": [
        {
          "input": "head = [1,2,3,4,5]",
          "output": "[5,4,3,2,1]",
          "explanation": "The list is reversed by changing the direction of the `next` pointers."
        }
      ],
      "constraints": [
        "The number of nodes in the list is in the range [0, 5000].",
        "-5000 <= Node.val <= 5000"
      ],
      "testCases": [
        {
          "input": {
            "head": [1,2,3,4,5]
          },
          "output": [5,4,3,2,1]
        },
        {
          "input": {
            "head": [1,2]
          },
          "output": [2,1]
        },
        {
          "input": {
            "head": []
          },
          "output": []
        }
      ],
      "javaTemplate": "class Solution { \n    public ListNode reverseList(ListNode head) { \n        return null; \n    } \n}",
      "pythonTemplate": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        pass",
      "cppTemplate": "class Solution { \npublic:\n    ListNode* reverseList(ListNode* head) { \n        return nullptr; \n    } \n};"
    },
    {
      "id": 42,
      "title": "Merge Two Sorted Lists",
      "difficulty": "Easy",
      "description": "You are given the heads of two sorted linked lists `list1` and `list2`. Merge the two lists in a single sorted list. The new list should be made by splicing together the nodes of the first two lists.",
      "hint": "A recursive or iterative approach can be used. With an iterative approach, use a dummy node to simplify the logic of handling the head of the new merged list.",
      "examples": [
        {
          "input": "list1 = [1,2,4], list2 = [1,3,4]",
          "output": "[1,1,2,3,4,4]",
          "explanation": "The merged list is sorted in ascending order."
        }
      ],
      "constraints": [
        "The number of nodes in both lists is in the range [0, 50].",
        "-100 <= Node.val <= 100",
        "Both `list1` and `list2` are sorted in non-decreasing order."
      ],
      "testCases": [
        {
          "input": {
            "list1": [1,2,4],
            "list2": [1,3,4]
          },
          "output": [1,1,2,3,4,4]
        },
        {
          "input": {
            "list1": [],
            "list2": []
          },
          "output": []
        },
        {
          "input": {
            "list1": [],
            "list2": [0]
          },
          "output": [0]
        }
      ],
      "javaTemplate": "class Solution { \n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) { \n        return null; \n    } \n}",
      "pythonTemplate": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        pass",
      "cppTemplate": "class Solution { \npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { \n        return nullptr; \n    } \n};"
    },
    {
      "id": 43,
      "title": "Remove Nth Node From End of List",
      "difficulty": "Medium",
      "description": "Given the `head` of a linked list, remove the `n`th node from the end of the list and return its head.",
      "hint": "Use two pointers. Move the first pointer `n+1` steps ahead. Then move both pointers until the first pointer reaches the end. The second pointer will be at the node before the one to be removed.",
      "examples": [
        {
          "input": "head = [1,2,3,4,5], n = 2",
          "output": "[1,2,3,5]",
          "explanation": "The 2nd node from the end (node with value 4) is removed."
        }
      ],
      "constraints": [
        "The number of nodes in the list is sz.",
        "1 <= sz <= 30",
        "0 <= Node.val <= 100",
        "1 <= n <= sz"
      ],
      "testCases": [
        {
          "input": {
            "head": [1,2,3,4,5],
            "n": 2
          },
          "output": [1,2,3,5]
        },
        {
          "input": {
            "head": [1],
            "n": 1
          },
          "output": []
        },
        {
          "input": {
            "head": [1,2],
            "n": 1
          },
          "output": [1]
        }
      ],
      "javaTemplate": "class Solution { \n    public ListNode removeNthFromEnd(ListNode head, int n) { \n        return null; \n    } \n}",
      "pythonTemplate": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        pass",
      "cppTemplate": "class Solution { \npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) { \n        return nullptr; \n    } \n};"
    },
    {
      "id": 44,
      "title": "Add Two Numbers",
      "difficulty": "Medium",
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
      "hint": "Simulate the process of adding two numbers digit by digit. Keep track of the carry and handle cases where the lists have different lengths.",
      "examples": [
        {
          "input": "l1 = [2,4,3], l2 = [5,6,4]",
          "output": "[7,0,8]",
          "explanation": "342 + 465 = 807."
        }
      ],
      "constraints": [
        "The number of nodes in each linked list is in the range [1, 100].",
        "0 <= Node.val <= 9",
        "It is guaranteed that the list represents a number that does not have leading zeros."
      ],
      "testCases": [
        {
          "input": {
            "l1": [2,4,3],
            "l2": [5,6,4]
          },
          "output": [7,0,8]
        },
        {
          "input": {
            "l1": [0],
            "l2": [0]
          },
          "output": [0]
        },
        {
          "input": {
            "l1": [9,9,9,9,9,9,9],
            "l2": [9,9,9,9]
          },
          "output": [8,9,9,9,0,0,0,1]
        }
      ],
      "javaTemplate": "class Solution { \n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) { \n        return null; \n    } \n}",
      "pythonTemplate": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        pass",
      "cppTemplate": "class Solution { \npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { \n        return nullptr; \n    } \n};"
    },
    {
      "id": 45,
      "title": "Linked List Cycle",
      "difficulty": "Easy",
      "description": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer.",
      "hint": "Use Floyd's cycle-finding algorithm (tortoise and hare). Use two pointers, one moving one step at a time and the other moving two steps at a time. If there's a cycle, they will eventually meet.",
      "examples": [
        {
          "input": "head = [3,2,0,-4], pos = 1",
          "output": "true",
          "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
        }
      ],
      "constraints": [
        "The number of the nodes in the list is in the range [0, 10^4].",
        "-10^5 <= Node.val <= 10^5",
        "pos is -1 or a valid index in the linked-list."
      ],
      "testCases": [
        {
          "input": {
            "head": [3,2,0,-4],
            "pos": 1
          },
          "output": true
        },
        {
          "input": {
            "head": [1,2],
            "pos": 0
          },
          "output": true
        }
      ],
      "javaTemplate": "class Solution { \n    public boolean hasCycle(ListNode head) { \n        return false; \n    } \n}",
      "pythonTemplate": "class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        pass",
      "cppTemplate": "class Solution { \npublic:\n    bool hasCycle(ListNode *head) { \n        return false; \n    } \n};"
    }
  ]
}
