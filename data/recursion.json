{
    "category": "Recursion",
    "problems": [
      {
        "id": 161,
        "title": "Factorial of a Number",
        "difficulty": "Easy",
        "description": "Write a recursive function to compute the factorial of a non-negative integer $n$.",
        "examples": [
          {
            "input": "n = 5",
            "output": "120"
          }
        ],
        "constraints": [
          "$0 <= n <= 12$"
        ],
        "testCases": [
          { "input": { "n": 5 }, "output": 120 },
          { "input": { "n": 0 }, "output": 1 },
          { "input": { "n": 1 }, "output": 1 }
        ],
        "javaTemplate": "class Solution { public int factorial(int n) { return 0; } }",
        "pythonTemplate": "class Solution: def factorial(self, n: int) -> int: pass",
        "cppTemplate": "class Solution { public: int factorial(int n) { return 0; } };"
      },
      {
        "id": 162,
        "title": "Fibonacci Number",
        "difficulty": "Easy",
        "description": "Return the $n$-th Fibonacci number. The Fibonacci sequence is defined as $F(0) = 0$, $F(1) = 1$, and $F(n) = F(n-1) + F(n-2)$ for $n > 1$.",
        "examples": [
          {
            "input": "n = 3",
            "output": "2"
          },
          {
            "input": "n = 4",
            "output": "3"
          }
        ],
        "constraints": [
          "$0 <= n <= 30$"
        ],
        "testCases": [
          { "input": { "n": 4 }, "output": 3 },
          { "input": { "n": 0 }, "output": 0 },
          { "input": { "n": 1 }, "output": 1 }
        ],
        "javaTemplate": "class Solution { public int fib(int n) { return 0; } }",
        "pythonTemplate": "class Solution: def fib(self, n: int) -> int: pass",
        "cppTemplate": "class Solution { public: int fib(int n) { return 0; } };"
      },
      {
        "id": 163,
        "title": "Reverse a String",
        "difficulty": "Easy",
        "description": "Write a recursive function to reverse a given string.",
        "examples": [
          {
            "input": "s = \"hello\"",
            "output": "\"olleh\""
          }
        ],
        "constraints": [
          "$1 <= s.length <= 1000$"
        ],
        "testCases": [
          { "input": { "s": "hello" }, "output": "olleh" },
          { "input": { "s": "a" }, "output": "a" },
          { "input": { "s": "ab" }, "output": "ba" }
        ],
        "javaTemplate": "class Solution { public String reverseString(String s) { return \"\"; } }",
        "pythonTemplate": "class Solution: def reverseString(self, s: str) -> str: pass",
        "cppTemplate": "class Solution { public: string reverseString(string s) { return \"\"; } };"
      },
      {
        "id": 164,
        "title": "Palindrome Number",
        "difficulty": "Easy",
        "description": "Given an integer $x$, return `true` if $x$ is a palindrome integer. An integer is a palindrome when it reads the same backward as forward. For example, $121$ is a palindrome while $123$ is not. Solve this using recursion.",
        "examples": [
          {
            "input": "x = 121",
            "output": "true"
          },
          {
            "input": "x = 123",
            "output": "false"
          }
        ],
        "constraints": [
          "$-2^{31} <= x <= 2^{31} - 1$"
        ],
        "testCases": [
          { "input": { "x": 121 }, "output": true },
          { "input": { "x": 123 }, "output": false },
          { "input": { "x": -121 }, "output": false }
        ],
        "javaTemplate": "class Solution { public boolean isPalindrome(int x) { return false; } }",
        "pythonTemplate": "class Solution: def isPalindrome(self, x: int) -> bool: pass",
        "cppTemplate": "class Solution { public: bool isPalindrome(int x) { return false; } };"
      },
      {
        "id": 165,
        "title": "Sum of Digits",
        "difficulty": "Easy",
        "description": "Write a recursive function to calculate the sum of the digits of a number.",
        "examples": [
          {
            "input": "n = 123",
            "output": "6"
          }
        ],
        "constraints": [
          "$0 <= n <= 10^9$"
        ],
        "testCases": [
          { "input": { "n": 123 }, "output": 6 },
          { "input": { "n": 0 }, "output": 0 },
          { "input": { "n": 9 }, "output": 9 }
        ],
        "javaTemplate": "class Solution { public int sumOfDigits(int n) { return 0; } }",
        "pythonTemplate": "class Solution: def sumOfDigits(self, n: int) -> int: pass",
        "cppTemplate": "class Solution { public: int sumOfDigits(int n) { return 0; } };"
      },
      {
        "id": 166,
        "title": "Climbing Stairs",
        "difficulty": "Medium",
        "description": "You are climbing a staircase. It takes $n$ steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
        "examples": [
          {
            "input": "n = 3",
            "output": "3"
          }
        ],
        "constraints": [
          "$1 <= n <= 45$"
        ],
        "testCases": [
          { "input": { "n": 3 }, "output": 3 },
          { "input": { "n": 1 }, "output": 1 },
          { "input": { "n": 2 }, "output": 2 }
        ],
        "javaTemplate": "class Solution { public int climbStairs(int n) { return 0; } }",
        "pythonTemplate": "class Solution: def climbStairs(self, n: int) -> int: pass",
        "cppTemplate": "class Solution { public: int climbStairs(int n) { return 0; } };"
      },
      {
        "id": 167,
        "title": "Subsets",
        "difficulty": "Medium",
        "description": "Given an integer array `nums` of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
          }
        ],
        "constraints": [
          "$1 <= nums.length <= 10$"
        ],
        "testCases": [
          { "input": { "nums": [1,2,3] }, "output": [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] },
          { "input": { "nums": [0] }, "output": [[],[0]] },
          { "input": { "nums": [1,2] }, "output": [[],[1],[2],[1,2]] }
        ],
        "javaTemplate": "class Solution { public List<List<Integer>> subsets(int[] nums) { return new ArrayList<>(); } }",
        "pythonTemplate": "class Solution: def subsets(self, nums: List[int]) -> List[List[int]]: pass",
        "cppTemplate": "class Solution { public: vector<vector<int>> subsets(vector<int>& nums) { return {}; } };"
      },
      {
        "id": 168,
        "title": "Permutations",
        "difficulty": "Medium",
        "description": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
          }
        ],
        "constraints": [
          "$1 <= nums.length <= 6$"
        ],
        "testCases": [
          { "input": { "nums": [1,2,3] }, "output": [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] }
        ],
        "javaTemplate": "class Solution { public List<List<Integer>> permute(int[] nums) { return new ArrayList<>(); } }",
        "pythonTemplate": "class Solution: def permute(self, nums: List[int]) -> List[List[int]]: pass",
        "cppTemplate": "class Solution { public: vector<vector<int>> permute(vector<int>& nums) { return {}; } };"
      },
      {
        "id": 169,
        "title": "Combination Sum",
        "difficulty": "Medium",
        "description": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order.",
        "examples": [
          {
            "input": "candidates = [2,3,6,7], target = 7",
            "output": "[[2,2,3],[7]]"
          }
        ],
        "constraints": [
          "$1 <= candidates.length <= 30$",
          "$2 <= candidates[i] <= 40$",
          "$1 <= target <= 40$"
        ],
        "testCases": [
          { "input": { "candidates": [2,3,6,7], "target": 7 }, "output": [[2,2,3],[7]] }
        ],
        "javaTemplate": "class Solution { public List<List<Integer>> combinationSum(int[] candidates, int target) { return new ArrayList<>(); } }",
        "pythonTemplate": "class Solution: def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]: pass",
        "cppTemplate": "class Solution { public: vector<vector<int>> combinationSum(vector<int>& candidates, int target) { return {}; } };"
      },
      {
        "id": 170,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": "Medium",
        "description": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. The mapping of digits to letters is the same as on a phone.",
        "examples": [
          {
            "input": "digits = \"23\"",
            "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
          }
        ],
        "constraints": [
          "$0 <= digits.length <= 4$"
        ],
        "testCases": [
          { "input": { "digits": "23" }, "output": ["ad","ae","af","bd","be","bf","cd","ce","cf"] }
        ],
        "javaTemplate": "class Solution { public List<String> letterCombinations(String digits) { return new ArrayList<>(); } }",
        "pythonTemplate": "class Solution: def letterCombinations(self, digits: str) -> List[str]: pass",
        "cppTemplate": "class Solution { public: vector<string> letterCombinations(string digits) { return {}; } };"
      },
      {
        "id": 171,
        "title": "Word Search",
        "difficulty": "Hard",
        "description": "Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
        "examples": [
          {
            "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
            "output": "true"
          }
        ],
        "constraints": [
          "$1 <= m, n <= 6$",
          "$1 <= word.length <= 15$"
        ],
        "testCases": [
          { "input": { "board": [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], "word": "ABCCED" }, "output": true }
        ],
        "javaTemplate": "class Solution { public boolean exist(char[][] board, String word) { return false; } }",
        "pythonTemplate": "class Solution: def exist(self, board: List[List[str]], word: str) -> bool: pass",
        "cppTemplate": "class Solution { public: bool exist(vector<vector<char>>& board, string word) { return false; } };"
      },
      {
        "id": 172,
        "title": "N-Queens",
        "difficulty": "Hard",
        "description": "The **N-Queens** puzzle is the problem of placing $n$ queens on an $n \times n$ chessboard such that no two queens attack each other. Given an integer $n$, return all distinct solutions to the **N-Queens** puzzle.",
        "examples": [
          {
            "input": "n = 4",
            "output": "[[ \".Q..\", \"...Q\", \"Q...\", \"..Q.\" ], [ \"..Q.\", \"Q...\", \"...Q\", \".Q..\" ]]"
          }
        ],
        "constraints": [
          "$1 <= n <= 9$"
        ],
        "testCases": [
          { "input": { "n": 4 }, "output": [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]] }
        ],
        "javaTemplate": "class Solution { public List<List<String>> solveNQueens(int n) { return new ArrayList<>(); } }",
        "pythonTemplate": "class Solution: def solveNQueens(self, n: int) -> List[List[str]]: pass",
        "cppTemplate": "class Solution { public: vector<vector<string>> solveNQueens(int n) { return {}; } };"
      },
      {
        "id": 173,
        "title": "Sudoku Solver",
        "difficulty": "Hard",
        "description": "Write a program to solve a Sudoku puzzle by filling the empty cells. A Sudoku board is a $9 \times 9$ grid. Each digit $1-9$ must appear exactly once in each row, column, and $3 \times 3$ sub-box. The empty cells are indicated by '.'.",
        "examples": [
          {
            "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
            "output": "[[..], [..], ..]"
          }
        ],
        "constraints": [
          "`board.length == 9`",
          "`board[i].length == 9`"
        ],
        "testCases": [
          { "input": { "board": [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],[["8",".",".",".","6",".",".",".","3"]],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]] }, "output": [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]] }
        ],
        "javaTemplate": "class Solution { public void solveSudoku(char[][] board) { } }",
        "pythonTemplate": "class Solution: def solveSudoku(self, board: List[List[str]]) -> None: pass",
        "cppTemplate": "class Solution { public: void solveSudoku(vector<vector<char>>& board) { } };"
      },
      {
        "id": 174,
        "title": "Word Ladder II",
        "difficulty": "Hard",
        "description": "A transformation sequence from `word1` to `word2` is a sequence of words from `wordList` such that: only one letter is changed at each step, each intermediate word exists in `wordList`, and the final word is `word2`. Given two words `beginWord` and `endWord`, and a dictionary `wordList`, find all shortest transformation sequences from `beginWord` to `endWord`.",
        "examples": [
          {
            "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
            "output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]"
          }
        ],
        "constraints": [
          "$1 <= beginWord.length <= 5$",
          "wordList contains distinct words."
        ],
        "testCases": [
          { "input": { "beginWord": "hit", "endWord": "cog", "wordList": ["hot","dot","dog","lot","log","cog"] }, "output": [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]] }
        ],
        "javaTemplate": "class Solution { public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) { return new ArrayList<>(); } }",
        "pythonTemplate": "from collections import deque\nclass Solution: def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]: pass",
        "cppTemplate": "class Solution { public: vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) { return {}; } };"
      },
      {
        "id": 175,
        "title": "Palindrome Partitioning II",
        "difficulty": "Hard",
        "description": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of `s`.",
        "examples": [
          {
            "input": "s = \"aab\"",
            "output": "1"
          }
        ],
        "constraints": [
          "$1 <= s.length <= 2000$"
        ],
        "testCases": [
          { "input": { "s": "aab" }, "output": 1 }
        ],
        "javaTemplate": "class Solution { public int minCut(String s) { return 0; } }",
        "pythonTemplate": "class Solution: def minCut(self, s: str) -> int: pass",
        "cppTemplate": "class Solution { public: int minCut(string s) { return 0; } };"
      },
      {
        "id": 176,
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "description": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `.` and `*`. The character `.` matches any single character. The character `*` matches zero or more of the preceding element.",
        "examples": [
          {
            "input": "s = \"aab\", p = \"c*a*b\"",
            "output": "true"
          }
        ],
        "constraints": [
          "$1 <= s.length <= 20$",
          "$1 <= p.length <= 30$"
        ],
        "testCases": [
          { "input": { "s": "aab", "p": "c*a*b" }, "output": true }
        ],
        "javaTemplate": "class Solution { public boolean isMatch(String s, String p) { return false; } }",
        "pythonTemplate": "class Solution: def isMatch(self, s: str, p: str) -> bool: pass",
        "cppTemplate": "class Solution { public: bool isMatch(string s, string p) { return false; } };"
      },
      {
        "id": 177,
        "title": "Distinct Subsequences",
        "difficulty": "Hard",
        "description": "Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equals `t`. A subsequence of a string is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters' relative positions.",
        "examples": [
          {
            "input": "s = \"rabbbit\", t = \"rabbit\"",
            "output": "3"
          }
        ],
        "constraints": [
          "$1 <= s.length, t.length <= 1000$"
        ],
        "testCases": [
          { "input": { "s": "rabbbit", "t": "rabbit" }, "output": 3 }
        ],
        "javaTemplate": "class Solution { public int numDistinct(String s, String t) { return 0; } }",
        "pythonTemplate": "class Solution: def numDistinct(self, s: str, t: str) -> int: pass",
        "cppTemplate": "class Solution { public: int numDistinct(string s, string t) { return 0; } };"
      },
      {
        "id": 178,
        "title": "Scramble String",
        "difficulty": "Hard",
        "description": "We can scramble a string `s` to get a string `t` using the following algorithm: 1. If the length of the string is 1, return it. 2. Otherwise, for a random index $i$ between $1$ and `length - 1`, divide the string into two non-empty substrings: `x = s[0...i-1]` and `y = s[i...length-1]`. 3. Scramble both substrings `x` and `y` independently. 4. Either concatenate the scrambled substrings in the original order (`x' + y'`) or in the reversed order (`y' + x'`). Given two strings `s1` and `s2`, return `true` if `s2` is a scrambled string of `s1`, otherwise `false`.",
        "examples": [
          {
            "input": "s1 = \"great\", s2 = \"rgeat\"",
            "output": "true"
          }
        ],
        "constraints": [
          "$1 <= s1.length, s2.length <= 30$"
        ],
        "testCases": [
          { "input": { "s1": "great", "s2": "rgeat" }, "output": true }
        ],
        "javaTemplate": "class Solution { public boolean isScramble(String s1, String s2) { return false; } }",
        "pythonTemplate": "class Solution: def isScramble(self, s1: str, s2: str) -> bool: pass",
        "cppTemplate": "class Solution { public: bool isScramble(string s1, string s2) { return false; } };"
      },
      {
        "id": 179,
        "title": "Unique Binary Search Trees II",
        "difficulty": "Hard",
        "description": "Given an integer $n$, return all structurally unique **Binary Search Tree**s (BST) which has exactly $n$ nodes of unique values from $1$ to $n$.",
        "examples": [
          {
            "input": "n = 3",
            "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]"
          }
        ],
        "constraints": [
          "$1 <= n <= 8$"
        ],
        "testCases": [
          { "input": { "n": 3 }, "output": [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] }
        ],
        "javaTemplate": "class Solution { public List<TreeNode> generateTrees(int n) { return new ArrayList<>(); } }",
        "pythonTemplate": "class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val; self.left = left; self.right = right\nclass Solution: def generateTrees(self, n: int) -> List[Optional[TreeNode]]: pass",
        "cppTemplate": "struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: vector<TreeNode*> generateTrees(int n) { return {}; } };"
      },
      {
        "id": 180,
        "title": "Maximum Length of Repeated Subarray",
        "difficulty": "Hard",
        "description": "Given two integer arrays `nums1` and `nums2`, return the maximum length of a subarray that appears in both arrays. You can solve this using recursion with memoization.",
        "examples": [
          {
            "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
            "output": "3"
          }
        ],
        "constraints": [
          "$1 <= nums1.length, nums2.length <= 1000$"
        ],
        "testCases": [
          { "input": { "nums1": [1,2,3,2,1], "nums2": [3,2,1,4,7] }, "output": 3 }
        ],
        "javaTemplate": "class Solution \n {\n public int findLength(int[] nums1, int[] nums2) \n{\n return 0; }\n }",
        "pythonTemplate": "class Solution: def findLength(self, nums1: List[int], nums2: List[int]) -> int: pass",
        "cppTemplate": "class Solution { public: int findLength(vector<int>& nums1, vector<int>& nums2) { return 0; } };"
      }
    ]
  }
  