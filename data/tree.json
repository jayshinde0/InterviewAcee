{
  "category": "Trees and Graphs",
  "problems": [
    {
      "id": 61,
      "title": "Invert Binary Tree",
      "difficulty": "Easy",
      "description": "Given the `root` of a binary tree, invert the tree, and return its `root`. This means swapping the left and right children of every node.",
      "hint": "You can solve this problem using either recursion or an iterative approach with a queue. For the recursive solution, the base case is a null node. In the recursive step, swap the children and then recursively call the function on the left and right subtrees.",
      "examples": [
        {
          "input": "root = [4,2,7,1,3,6,9]",
          "output": "[4,7,2,9,6,3,1]",
          "explanation": "The left and right subtrees of each node are swapped."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 100].",
        "-100 <= Node.val <= 100"
      ],
      "testCases": [
        {
          "input": { "root": [4,2,7,1,3,6,9] },
          "output": [4,7,2,9,6,3,1]
        },
        {
          "input": { "root": [2,1,3] },
          "output": [2,3,1]
        },
        {
          "input": { "root": [] },
          "output": []
        }
      ],
      "javaTemplate": "class Solution { public TreeNode invertTree(TreeNode root) { return null; } }",
      "pythonTemplate": "class Solution: def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]: pass",
      "cppTemplate": "class Solution { public: TreeNode* invertTree(TreeNode* root) { return nullptr; } };"
    },
    {
      "id": 62,
      "title": "Maximum Depth of Binary Tree",
      "difficulty": "Easy",
      "description": "Given the `root` of a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "hint": "This is a classic recursive problem. The maximum depth of a node is one plus the maximum depth of its left and right subtrees.",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "3",
          "explanation": "The path to the farthest leaf is 3 -> 20 -> 7, which has a length of 3."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 10^4].",
        "-100 <= Node.val <= 100"
      ],
      "testCases": [
        {
          "input": { "root": [3,9,20,null,null,15,7] },
          "output": 3
        },
        {
          "input": { "root": [1,null,2] },
          "output": 2
        },
        {
          "input": { "root": [] },
          "output": 0
        }
      ],
      "javaTemplate": "class Solution { public int maxDepth(TreeNode root) { return 0; } }",
      "pythonTemplate": "class Solution: def maxDepth(self, root: Optional[TreeNode]) -> int: pass",
      "cppTemplate": "class Solution { public: int maxDepth(TreeNode* root) { return 0; } };"
    },
    {
      "id": 63,
      "title": "Same Tree",
      "difficulty": "Easy",
      "description": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
      "hint": "You can use recursion. Check if both roots are null (return true). If one is null and the other isn't, they are not the same (return false). If they both exist, check if their values are equal and then recursively check their left and right subtrees.",
      "examples": [
        {
          "input": "p = [1,2,3], q = [1,2,3]",
          "output": "true",
          "explanation": "Both trees have the same structure and node values."
        }
      ],
      "constraints": [
        "The number of nodes in both trees is in the range [0, 100].",
        "-100 <= Node.val <= 100"
      ],
      "testCases": [
        {
          "input": { "p": [1,2,3], "q": [1,2,3] },
          "output": true
        },
        {
          "input": { "p": [1,2], "q": [1,null,2] },
          "output": false
        },
        {
          "input": { "p": [1,2,1], "q": [1,1,2] },
          "output": false
        }
      ],
      "javaTemplate": "class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { return false; } }",
      "pythonTemplate": "class Solution: def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool: pass",
      "cppTemplate": "class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { return false; } };"
    },
    {
      "id": 64,
      "title": "Symmetric Tree",
      "difficulty": "Easy",
      "description": "Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
      "hint": "This can be solved by writing a helper function that takes two nodes, say `p` and `q`, and checks if `p`'s left child is the mirror of `q`'s right child and `p`'s right child is the mirror of `q`'s left child. The base case is when both nodes are null. If one is null and the other isn't, they are not symmetric.",
      "examples": [
        {
          "input": "root = [1,2,2,3,4,4,3]",
          "output": "true",
          "explanation": "The tree is symmetric."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [1, 1000].",
        "-100 <= Node.val <= 100"
      ],
      "testCases": [
        {
          "input": { "root": [1,2,2,3,4,4,3] },
          "output": true
        },
        {
          "input": { "root": [1,2,2,null,3,null,3] },
          "output": false
        },
        {
          "input": { "root": [1] },
          "output": true
        }
      ],
      "javaTemplate": "class Solution { public boolean isSymmetric(TreeNode root) { return false; } }",
      "pythonTemplate": "class Solution: def isSymmetric(self, root: Optional[TreeNode]) -> bool: pass",
      "cppTemplate": "class Solution { public: bool isSymmetric(TreeNode* root) { return false; } };"
    },
    {
      "id": 65,
      "title": "Binary Tree Level Order Traversal",
      "difficulty": "Medium",
      "description": "Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
      "hint": "Use a queue data structure to perform a breadth-first search. Start by adding the root to the queue. In a loop, dequeue a node, add its value to the current level's list, and enqueue its children. Use a marker or a counter to know when a level ends.",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "[[3],[9,20],[15,7]]",
          "explanation": "The nodes are traversed level by level."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 2000].",
        "-1000 <= Node.val <= 1000"
      ],
      "testCases": [
        {
          "input": { "root": [3,9,20,null,null,15,7] },
          "output": [[3],[9,20],[15,7]]
        },
        {
          "input": { "root": [] },
          "output": []
        },
        {
          "input": { "root": [1] },
          "output": [[1]]
        }
      ],
      "javaTemplate": "class Solution { public List<List<Integer>> levelOrder(TreeNode root) { return new ArrayList<>(); } }",
      "pythonTemplate": "class Solution: def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]: pass",
      "cppTemplate": "class Solution { public: vector<vector<int>> levelOrder(TreeNode* root) { return {}; } };"
    },
    {
      "id": 66,
      "title": "Validate Binary Search Tree",
      "difficulty": "Medium",
      "description": "Given the `root` of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with values less than the node's value. The right subtree of a node contains only nodes with values greater than the node's value. Both the left and right subtrees must also be valid BSTs.",
      "hint": "A recursive solution can be implemented with a helper function that takes a node and a range of valid values (lower and upper bounds). For the left subtree, the upper bound is the current node's value. For the right subtree, the lower bound is the current node's value. The initial call should have a very large range.",
      "examples": [
        {
          "input": "root = [2,1,3]",
          "output": "true",
          "explanation": "This is a valid BST."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [1, 10^4].",
        "-2^31 <= Node.val <= 2^31 - 1"
      ],
      "testCases": [
        {
          "input": { "root": [2,1,3] },
          "output": true
        },
        {
          "input": { "root": [5,1,4,null,null,3,6] },
          "output": false
        },
        {
          "input": { "root": [1] },
          "output": true
        }
      ],
      "javaTemplate": "class Solution { public boolean isValidBST(TreeNode root) { return false; } }",
      "pythonTemplate": "class Solution: def isValidBST(self, root: Optional[TreeNode]) -> bool: pass",
      "cppTemplate": "class Solution { public: bool isValidBST(TreeNode* root) { return false; } };"
    },
    {
      "id": 67,
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "difficulty": "Easy",
      "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes, `p` and `q`.",
      "hint": "Since it is a BST, you can use the properties of the tree to your advantage. If both `p` and `q` are smaller than the current node, the LCA must be in the left subtree. If both are larger, it must be in the right subtree. Otherwise, the current node is the LCA.",
      "examples": [
        {
          "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
          "output": "6",
          "explanation": "The LCA of nodes 2 and 8 is 6."
        }
      ],
      "constraints": [
        "The number of nodes in the BST is in the range [2, 10^5].",
        "-10^9 <= Node.val <= 10^9"
      ],
      "testCases": [
        {
          "input": { "root": [6,2,8,0,4,7,9,null,null,3,5], "p": 2, "q": 8 },
          "output": 6
        },
        {
          "input": { "root": [6,2,8,0,4,7,9,null,null,3,5], "p": 2, "q": 4 },
          "output": 2
        }
      ],
      "javaTemplate": "class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return null; } }",
      "pythonTemplate": "class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': pass",
      "cppTemplate": "class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { return nullptr; } };"
    },
    {
      "id": 68,
      "title": "Kth Smallest Element in a BST",
      "difficulty": "Medium",
      "description": "Given the `root` of a binary search tree, and an integer `k`, return the `k`-th smallest value (1-indexed) of all the values in the tree.",
      "hint": "An in-order traversal of a BST visits the nodes in ascending order. You can perform an in-order traversal and keep a counter. When the counter reaches `k`, you've found the `k`-th smallest element.",
      "examples": [
        {
          "input": "root = [3,1,4,null,2], k = 1",
          "output": "1",
          "explanation": "The in-order traversal is [1, 2, 3, 4]. The 1st smallest is 1."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [1, 10^4].",
        "0 <= Node.val <= 10^4"
      ],
      "testCases": [
        {
          "input": { "root": [3,1,4,null,2], "k": 1 },
          "output": 1
        },
        {
          "input": { "root": [5,3,6,2,4,null,null,1], "k": 3 },
          "output": 3
        }
      ],
      "javaTemplate": "class Solution { public int kthSmallest(TreeNode root, int k) { return 0; } }",
      "pythonTemplate": "class Solution: def kthSmallest(self, root: Optional[TreeNode], k: int) -> int: pass",
      "cppTemplate": "class Solution { public: int kthSmallest(TreeNode* root, int k) { return 0; } };"
    },
    {
      "id": 69,
      "title": "Binary Tree Zigzag Level Order Traversal",
      "difficulty": "Medium",
      "description": "Given the `root` of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
      "hint": "Use a queue for level order traversal, but maintain a flag to indicate the current direction. When adding nodes to the result list, add them to the front for right-to-left levels and to the back for left-to-right levels.",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "[[3],[20,9],[15,7]]",
          "explanation": "The nodes are traversed zigzag."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 2000].",
        "-100 <= Node.val <= 100"
      ],
      "testCases": [
        {
          "input": { "root": [3,9,20,null,null,15,7] },
          "output": [[3],[20,9],[15,7]]
        },
        {
          "input": { "root": [] },
          "output": []
        }
      ],
      "javaTemplate": "class Solution { public List<List<Integer>> zigzagLevelOrder(TreeNode root) { return new ArrayList<>(); } }",
      "pythonTemplate": "class Solution: def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]: pass",
      "cppTemplate": "class Solution { public: vector<vector<int>> zigzagLevelOrder(TreeNode* root) { return {}; } };"
    },
    {
      "id": 70,
      "title": "Count Complete Tree Nodes",
      "difficulty": "Medium",
      "description": "Given the `root` of a complete binary tree, return the number of nodes in the tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.",
      "hint": "You can solve this in better than O(N) time. If the height of the left and right subtrees are equal, it means the left subtree is a perfect binary tree, and you can calculate its nodes using 2^h - 1. If not, the right subtree is a perfect binary tree.",
      "examples": [
        {
          "input": "root = [1,2,3,4,5,6]",
          "output": "6",
          "explanation": "The tree has 6 nodes."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 5 * 10^4].",
        "-10^6 <= Node.val <= 10^6"
      ],
      "testCases": [
        {
          "input": { "root": [1,2,3,4,5,6] },
          "output": 6
        },
        {
          "input": { "root": [1] },
          "output": 1
        }
      ],
      "javaTemplate": "class Solution { public int countNodes(TreeNode root) { return 0; } }",
      "pythonTemplate": "class Solution: def countNodes(self, root: Optional[TreeNode]) -> int: pass",
      "cppTemplate": "class Solution { public: int countNodes(TreeNode* root) { return 0; } };"
    },
    {
      "id": 71,
      "title": "Balanced Binary Tree",
      "difficulty": "Easy",
      "description": "Given the `root` of a binary tree, determine if it is height-balanced. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
      "hint": "You can solve this problem recursively. Define a helper function that returns the height of the subtree rooted at a node. If at any point the difference in heights of the left and right subtrees is greater than 1, the tree is not balanced.",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "true",
          "explanation": "The tree is balanced."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 5000].",
        "-100 <= Node.val <= 100"
      ],
      "testCases": [
        {
          "input": { "root": [3,9,20,null,null,15,7] },
          "output": true
        },
        {
          "input": { "root": [1,2,2,3,3,null,null,4,4] },
          "output": false
        }
      ],
      "javaTemplate": "class Solution { public boolean isBalanced(TreeNode root) { return false; } }",
      "pythonTemplate": "class Solution: def isBalanced(self, root: Optional[TreeNode]) -> bool: pass",
      "cppTemplate": "class Solution { public: bool isBalanced(TreeNode* root) { return false; } };"
    },
    {
      "id": 72,
      "title": "Path Sum",
      "difficulty": "Easy",
      "description": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a root-to-leaf path such that adding up all the values along the path equals `targetSum`.",
      "hint": "Use a recursive approach. At each node, check if it's a leaf. If it is, check if the remaining `targetSum` is equal to the node's value. If not a leaf, recursively call the function for its children, subtracting the current node's value from the `targetSum`.",
      "examples": [
        {
          "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
          "output": "true",
          "explanation": "The path 5 -> 4 -> 11 -> 2 sums to 22."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 5000].",
        "-1000 <= Node.val <= 1000",
        "-1000 <= targetSum <= 1000"
      ],
      "testCases": [
        {
          "input": { "root": [5,4,8,11,null,13,4,7,2,null,null,null,1], "targetSum": 22 },
          "output": true
        },
        {
          "input": { "root": [1,2,3], "targetSum": 5 },
          "output": false
        }
      ],
      "javaTemplate": "class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { return false; } }",
      "pythonTemplate": "class Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool: pass",
      "cppTemplate": "class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { return false; } };"
    },
    {
      "id": 73,
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "difficulty": "Medium",
      "description": "Given two integer arrays, `preorder` and `inorder`, where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return the binary tree.",
      "hint": "The first element in the preorder traversal is always the root. In the inorder traversal, all elements to the left of the root are in the left subtree, and all elements to the right are in the right subtree. You can use these facts to recursively build the tree.",
      "examples": [
        {
          "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
          "output": "[3,9,20,null,null,15,7]",
          "explanation": "The preorder and inorder traversals are used to construct the binary tree."
        }
      ],
      "constraints": [
        "1 <= preorder.length <= 3000",
        "inorder.length == preorder.length",
        "-3000 <= preorder[i], inorder[i] <= 3000"
      ],
      "testCases": [
        {
          "input": { "preorder": [3,9,20,15,7], "inorder": [9,3,15,20,7] },
          "output": [3,9,20,null,null,15,7]
        }
      ],
      "javaTemplate": "class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return null; } }",
      "pythonTemplate": "class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]: pass",
      "cppTemplate": "class Solution { public: TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) { return nullptr; } };"
    },
    {
      "id": 74,
      "title": "Binary Tree Right Side View",
      "difficulty": "Medium",
      "description": "Given the `root` of a binary tree, imagine you are standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom.",
      "hint": "This problem is a variation of level order traversal. For each level, the last node added to the list is the one on the right side. So, a level-by-level (BFS) approach can be used. Another way is to use a recursive DFS approach: traverse the right subtree first, and for each level, add the first node you visit to the result list.",
      "examples": [
        {
          "input": "root = [1,2,3,null,5,null,4]",
          "output": "[1,3,4]",
          "explanation": "The nodes visible from the right side are 1, 3, and 4."
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 100].",
        "-100 <= Node.val <= 100"
      ],
      "testCases": [
        {
          "input": { "root": [1,2,3,null,5,null,4] },
          "output": [1,3,4]
        },
        {
          "input": { "root": [1,null,3] },
          "output": [1,3]
        }
      ],
      "javaTemplate": "class Solution { public List<Integer> rightSideView(TreeNode root) { return new ArrayList<>(); } }",
      "pythonTemplate": "class Solution: def rightSideView(self, root: Optional[TreeNode]) -> List[int]: pass",
      "cppTemplate": "class Solution { public: vector<int> rightSideView(TreeNode* root) { return {}; } };"
    },
    {
      "id": 75,
      "title": "Number of Islands",
      "difficulty": "Medium",
      "description": "Given an m x n 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
      "hint": "Use a traversal algorithm like Depth First Search (DFS) or Breadth First Search (BFS). Iterate through each cell of the grid. If you find a '1', increment the island count and start a traversal from that cell to find all connected '1's, marking them as visited (e.g., changing '1' to '0') to avoid recounting.",
      "examples": [
        {
          "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
          "output": "1",
          "explanation": "There is only one large island."
        }
      ],
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 300",
        "grid[i][j] is '0' or '1'."
      ],
      "testCases": [
        {
          "input": { "grid": [["1","1","1","1","0"],["1","1","0","1","0"],["1","1","0","0","0"],["0","0","0","0","0"]] },
          "output": 1
        },
        {
          "input": { "grid": [["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]] },
          "output": 3
        }
      ],
      "javaTemplate": "class Solution { public int numIslands(char[][] grid) { return 0; } }",
      "pythonTemplate": "class Solution: def numIslands(self, grid: List[List[str]]) -> int: pass",
      "cppTemplate": "class Solution { public: int numIslands(vector<vector<char>>& grid) { return 0; } };"
    },
    {
      "id": 76,
      "title": "Clone Graph",
      "difficulty": "Medium",
      "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value and a list of its neighbors. The graph is represented as a list of nodes.",
      "hint": "You can use a hash map to keep track of the original nodes and their corresponding cloned nodes. Use a DFS or BFS traversal to visit each node. For each original node, create a clone if one doesn't exist in the hash map, then recursively or iteratively clone its neighbors.",
      "examples": [
        {
          "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
          "output": "[[2,4],[1,3],[2,4],[1,3]]",
          "explanation": "The graph is cloned with the same structure and node values."
        }
      ],
      "constraints": [
        "The number of nodes in the graph is in the range [0, 100].",
        "1 <= Node.val <= 100"
      ],
      "testCases": [
        {
          "input": { "adjList": [[2,4],[1,3],[2,4],[1,3]] },
          "output": [[2,4],[1,3],[2,4],[1,3]]
        }
      ],
      "javaTemplate": "class Solution { public Node cloneGraph(Node node) { return null; } }",
      "pythonTemplate": "class Solution: def cloneGraph(self, node: Optional['Node']) -> Optional['Node']: pass",
      "cppTemplate": "class Solution { public: Node* cloneGraph(Node* node) { return nullptr; } };"
    },
    {
      "id": 77,
      "title": "Course Schedule",
      "difficulty": "Medium",
      "description": "There are a total of `numCourses` courses you have to take, labeled from 0 to `numCourses` - 1. You are given a list of `prerequisites` where `prerequisites[i] = [a_i, b_i]` indicates that you must take course b_i first if you want to take course a_i. Return `true` if you can finish all courses. Otherwise, return `false`.",
      "hint": "This problem is about detecting a cycle in a directed graph. You can model the courses as nodes and prerequisites as directed edges. Use Depth First Search (DFS) with three states for each node: unvisited, visiting, and visited. A cycle is found if you encounter a 'visiting' node during a traversal.",
      "examples": [
        {
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "output": "true",
          "explanation": "To take course 1, you must first take course 0. This is possible."
        }
      ],
      "constraints": [
        "1 <= numCourses <= 2000",
        "0 <= prerequisites.length <= 5000"
      ],
      "testCases": [
        {
          "input": { "numCourses": 2, "prerequisites": [[1,0]] },
          "output": true
        },
        {
          "input": { "numCourses": 2, "prerequisites": [[1,0],[0,1]] },
          "output": false
        }
      ],
      "javaTemplate": "class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { return false; } }",
      "pythonTemplate": "class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool: pass",
      "cppTemplate": "class Solution { public: bool canFinish(int numCourses, vector<vector<int>>& prerequisites) { return false; } };"
    },
    {
      "id": 78,
      "title": "Number of Connected Components in an Undirected Graph",
      "difficulty": "Medium",
      "description": "Given `n` nodes labeled from 0 to n-1 and a list of `edges` which are a list of undirected pairs, write a function to find the number of connected components in the graph.",
      "hint": "You can solve this using either DFS/BFS or Union-Find. With DFS/BFS, iterate through each node. If a node hasn't been visited, increment the component count and start a traversal from that node, marking all reachable nodes as visited.",
      "examples": [
        {
          "input": "n = 5, edges = [[0,1],[1,2],[3,4]]",
          "output": "2",
          "explanation": "The two connected components are `{0,1,2}` and `{3,4}`."
        }
      ],
      "constraints": [
        "1 <= n <= 2000",
        "1 <= edges.length <= 5000",
        "edges[i].length == 2"
      ],
      "testCases": [
        {
          "input": { "n": 5, "edges": [[0,1],[1,2],[3,4]] },
          "output": 2
        },
        {
          "input": { "n": 5, "edges": [[0,1],[1,2],[2,3],[3,4]] },
          "output": 1
        }
      ],
      "javaTemplate": "class Solution { public int countComponents(int n, int[][] edges) { return 0; } }",
      "pythonTemplate": "class Solution: def countComponents(self, n: int, edges: List[List[int]]) -> int: pass",
      "cppTemplate": "class Solution { public: int countComponents(int n, vector<vector<int>>& edges) { return 0; } };"
    },
    {
      "id": 79,
      "title": "Graph Valid Tree",
      "difficulty": "Medium",
      "description": "Given `n` nodes labeled from 0 to n-1 and a list of `edges`, write a function to check whether these edges make up a valid tree. A valid tree is a connected graph with no cycles.",
      "hint": "A graph is a valid tree if and only if it is connected and has no cycles. You can check for connectivity by ensuring all nodes are visited in a single traversal (e.g., DFS or BFS) and check for cycles using a parent pointer during the traversal. A cycle exists if you visit an already-visited node that is not the direct parent.",
      "examples": [
        {
          "input": "n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]",
          "output": "true",
          "explanation": "The graph is a valid tree."
        }
      ],
      "constraints": [
        "1 <= n <= 2000",
        "1 <= edges.length <= 5000",
        "edges[i].length == 2"
      ],
      "testCases": [
        {
          "input": { "n": 5, "edges": [[0,1],[0,2],[0,3],[1,4]] },
          "output": true
        },
        {
          "input": { "n": 5, "edges": [[0,1],[1,2],[2,3],[1,3],[1,4]] },
          "output": false
        }
      ],
      "javaTemplate": "class Solution { public boolean validTree(int n, int[][] edges) { return false; } }",
      "pythonTemplate": "class Solution: def validTree(self, n: int, edges: List[List[int]]) -> bool: pass",
      "cppTemplate": "class Solution { public: bool validTree(int n, vector<vector<int>>& edges) { return false; } };"
    },
    {
      "id": 80,
      "title": "Word Ladder",
      "difficulty": "Hard",
      "description": "Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return the length of the shortest transformation sequence from `beginWord` to `endWord`. A transformation sequence is a chain of words where each adjacent word differs by a single letter. All words in the sequence must be in the `wordList` or `beginWord`.",
      "hint": "This is a classic Breadth First Search (BFS) problem. Model the words as nodes in a graph and a single-letter difference as an edge. BFS is ideal for finding the shortest path in an unweighted graph. Use a queue and a set to keep track of visited words.",
      "examples": [
        {
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "output": "5",
          "explanation": "One shortest sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"."
        }
      ],
      "constraints": [
        "1 <= beginWord.length <= 10",
        "endWord.length == beginWord.length",
        "1 <= wordList.length <= 5000"
      ],
      "testCases": [
        {
          "input": { "beginWord": "hit", "endWord": "cog", "wordList": ["hot","dot","dog","lot","log","cog"] },
          "output": 5
        },
        {
          "input": { "beginWord": "a", "endWord": "c", "wordList": ["a","b","c"] },
          "output": 2
        }
      ],
      "javaTemplate": "class Solution { public int ladderLength(String beginWord, String endWord, List<String> wordList) { return 0; } }",
      "pythonTemplate": "class Solution: def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int: pass",
      "cppTemplate": "class Solution { public: int ladderLength(string beginWord, string endWord, vector<string>& wordList) { return 0; } };"
    }
  ]
}
